<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="interactive-widget" content="resizes-content">
    <title>Beat</title>
    <style>
        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
        html, body { height: 100%; overflow: hidden; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #1a1a2e; color: #e0e0e0; }
        .chat-container { display: flex; flex-direction: column; height: 100vh; height: 100dvh; }
        .header { display: flex; align-items: center; justify-content: space-between; padding: 12px 16px; background: #16213e; border-bottom: 1px solid #0f3460; flex-shrink: 0; }
        .header h1 { font-size: 18px; font-weight: 600; }
        .header-buttons { display: flex; gap: 12px; }
        .header-btn { background: none; border: none; color: #e0e0e0; font-size: 20px; cursor: pointer; padding: 4px 8px; border-radius: 6px; }
        .header-btn:hover { background: rgba(255,255,255,0.1); }
        .messages { flex: 1; overflow-y: auto; padding: 16px; display: flex; flex-direction: column; gap: 12px; scroll-behavior: smooth; }
        .bubble { max-width: 80%; padding: 12px 16px; border-radius: 16px; line-height: 1.5; word-wrap: break-word; white-space: pre-wrap; font-size: 15px; }
        .bubble.user { align-self: flex-end; background: #16213e; border-bottom-right-radius: 4px; }
        .bubble.assistant { align-self: flex-start; background: #0f3460; border-bottom-left-radius: 4px; }
        .bubble.error { align-self: flex-start; background: #4a1942; border-bottom-left-radius: 4px; color: #ff9999; }
        .bubble.loading::after { content: '...'; animation: dots 1s steps(3, end) infinite; }
        @keyframes dots { 0% { content: '.'; } 33% { content: '..'; } 66% { content: '...'; } }
        .bubble .sources { margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.15); font-size: 12px; color: #999; }
        .bubble .sources a { color: #7aafff; text-decoration: none; }
        .bubble .sources a:hover { text-decoration: underline; }
        .attachment-preview { display: none; align-items: center; gap: 8px; padding: 8px 16px; background: #16213e; border-top: 1px solid #0f3460; flex-shrink: 0; }
        .attachment-preview.active { display: flex; }
        .attachment-preview img { max-height: 60px; max-width: 120px; border-radius: 8px; object-fit: cover; }
        .attachment-preview .file-name { font-size: 13px; color: #aaa; flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .attachment-preview .remove-btn { background: none; border: none; color: #ff9999; font-size: 18px; cursor: pointer; padding: 4px 8px; }
        .input-bar { display: flex; gap: 8px; padding: 12px 16px; background: #16213e; border-top: 1px solid #0f3460; flex-shrink: 0; align-items: flex-end; }
        .input-bar textarea { flex: 1; background: #1a1a2e; border: 1px solid #0f3460; border-radius: 12px; padding: 10px 14px; color: #e0e0e0; font-size: 15px; font-family: inherit; resize: none; outline: none; max-height: 120px; line-height: 1.4; }
        .input-bar textarea::placeholder { color: #666; }
        .input-bar button { background: #0f3460; border: none; color: #e0e0e0; border-radius: 12px; padding: 10px 16px; font-size: 15px; cursor: pointer; flex-shrink: 0; }
        .input-bar button:disabled { opacity: 0.5; cursor: not-allowed; }
        .input-bar button:hover:not(:disabled) { background: #1a4a8a; }
        .attach-btn { background: none !important; border: none; color: #e0e0e0; font-size: 22px; cursor: pointer; padding: 8px; border-radius: 12px; flex-shrink: 0; }
        .attach-btn:hover { background: rgba(255,255,255,0.1) !important; }
        .modal-overlay { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.7); z-index: 100; align-items: center; justify-content: center; }
        .modal-overlay.active { display: flex; }
        .modal-content { background: #16213e; border-radius: 16px; padding: 24px; width: 90%; max-width: 400px; }
        .modal-content h2 { margin-bottom: 16px; font-size: 18px; }
        .modal-input { width: 100%; background: #1a1a2e; border: 1px solid #0f3460; border-radius: 8px; padding: 10px 12px; color: #e0e0e0; font-size: 15px; font-family: inherit; outline: none; margin-bottom: 12px; }
        .modal-button { width: 100%; background: #0f3460; border: none; color: #e0e0e0; border-radius: 8px; padding: 10px; font-size: 15px; cursor: pointer; }
        .modal-button:hover { background: #1a4a8a; }
        .bubble img.attachment-img { max-width: 100%; max-height: 300px; border-radius: 8px; margin-bottom: 8px; display: block; }
    </style>
</head>
<body>
<div class="chat-container">
    <div class="header">
        <h1>Beat</h1>
        <div class="header-buttons">
            <button class="header-btn" onclick="clearChat()" title="Clear chat">&#128465;</button>
            <button class="header-btn" onclick="openSettings()" title="Settings">&#9881;</button>
        </div>
    </div>
    <div class="messages" id="messages"></div>
    <div class="attachment-preview" id="attachmentPreview">
        <img id="attachmentThumb" src="" alt="">
        <span class="file-name" id="attachmentName"></span>
        <button class="remove-btn" onclick="removeAttachment()" title="Remove">&#10005;</button>
    </div>
    <div class="input-bar">
        <button class="attach-btn" onclick="document.getElementById('fileInput').click()" title="Attach file">&#128206;</button>
        <input type="file" id="fileInput" accept="image/*,.pdf,.txt,.csv,.md" style="display:none" onchange="handleFileSelect(event)">
        <textarea id="input" rows="1" placeholder="Type a message..." onkeydown="handleKey(event)"></textarea>
        <button id="sendBtn" onclick="sendMessage()">Send</button>
    </div>
</div>
<div class="modal-overlay" id="modalOverlay">
    <div class="modal-content">
        <h2>&#9881; Gemini API Key</h2>
        <form onsubmit="saveApiKey(); return false;">
            <input type="password" class="modal-input" id="apiKeyInput" placeholder="AIza..." autocomplete="off" spellcheck="false">
            <button type="submit" class="modal-button">Save</button>
        </form>
    </div>
</div>
<script>
var SYSTEM_INSTRUCTION = "Your name is Beat. You are the user's personal assistant. When asked who you are, respond: \"I am Beat, your personal assistant, here to help.\" Always refer to yourself as Beat. You are a helpful, accurate general-knowledge assistant. Answer concisely. If uncertain, say so. Do not fabricate information. When you use Google Search to answer a question, mention the key sources naturally in your response. When asked to assess whether a text was written by AI, analyse it for patterns such as: uniform sentence structure, generic phrasing, hedging language, lack of personal voice or typos, overly formal tone, repetitive transition words, lack of specific or personal details, and unusually consistent paragraph length. Provide your assessment with a confidence level (low, medium, or high) and explain your reasoning. Always caveat that AI detection is inherently unreliable and your assessment is an educated guess, not a definitive answer.";

var conversationHistory = [];
var apiKey = localStorage.getItem('gemini_api_key') || '';
var messagesEl = document.getElementById('messages');
var inputEl = document.getElementById('input');
var sendBtn = document.getElementById('sendBtn');
var modalOverlay = document.getElementById('modalOverlay');
var apiKeyInput = document.getElementById('apiKeyInput');
var attachmentPreview = document.getElementById('attachmentPreview');
var attachmentThumb = document.getElementById('attachmentThumb');
var attachmentName = document.getElementById('attachmentName');
var pendingAttachment = null;

if (!apiKey) openSettings();

function openSettings() {
    apiKeyInput.value = apiKey;
    modalOverlay.classList.add('active');
    apiKeyInput.focus();
}

function saveApiKey() {
    var val = apiKeyInput.value.trim();
    if (val) {
        apiKey = val;
        localStorage.setItem('gemini_api_key', apiKey);
    }
    modalOverlay.classList.remove('active');
    inputEl.focus();
}

modalOverlay.addEventListener('click', function(e) {
    if (e.target === modalOverlay) modalOverlay.classList.remove('active');
});

function handleFileSelect(event) {
    var file = event.target.files[0];
    if (!file) return;
    if (file.size > 4 * 1024 * 1024) {
        alert('File must be under 4 MB.');
        event.target.value = '';
        return;
    }
    var reader = new FileReader();
    reader.onload = function(e) {
        var dataUrl = e.target.result;
        var mimeType = file.type || 'application/octet-stream';
        var base64 = dataUrl.split(',')[1];
        pendingAttachment = { mimeType: mimeType, base64: base64, name: file.name, dataUrl: dataUrl };
        attachmentName.textContent = file.name;
        if (mimeType.startsWith('image/')) {
            attachmentThumb.src = dataUrl;
            attachmentThumb.style.display = 'block';
        } else {
            attachmentThumb.style.display = 'none';
        }
        attachmentPreview.classList.add('active');
    };
    reader.readAsDataURL(file);
    event.target.value = '';
}

function removeAttachment() {
    pendingAttachment = null;
    attachmentPreview.classList.remove('active');
    attachmentThumb.src = '';
    attachmentThumb.style.display = 'none';
    attachmentName.textContent = '';
}

function appendBubble(role, text, imageDataUrl) {
    var div = document.createElement('div');
    div.className = 'bubble ' + role;
    if (imageDataUrl) {
        var img = document.createElement('img');
        img.className = 'attachment-img';
        img.src = imageDataUrl;
        div.appendChild(img);
    }
    if (text) {
        var span = document.createElement('span');
        span.textContent = text;
        div.appendChild(span);
    }
    messagesEl.appendChild(div);
    scrollToBottom();
    return div;
}

function appendLoadingBubble() {
    var div = document.createElement('div');
    div.className = 'bubble assistant loading';
    div.textContent = '';
    messagesEl.appendChild(div);
    scrollToBottom();
    return div;
}

function replaceLoadingWithContent(el, text, sources) {
    el.classList.remove('loading');
    el.textContent = '';
    var span = document.createElement('span');
    span.textContent = text;
    el.appendChild(span);
    if (sources && sources.length > 0) {
        var srcDiv = document.createElement('div');
        srcDiv.className = 'sources';
        srcDiv.innerHTML = 'Sources: ' + sources.map(function(s) {
            return '<a href="' + s.uri + '" target="_blank" rel="noopener">' + (s.title || s.uri) + '</a>';
        }).join(', ');
        el.appendChild(srcDiv);
    }
    scrollToBottom();
}

function replaceLoadingWithError(el, text) {
    el.classList.remove('loading');
    el.classList.remove('assistant');
    el.classList.add('error');
    el.textContent = text;
    scrollToBottom();
}

function scrollToBottom() {
    messagesEl.scrollTop = messagesEl.scrollHeight;
}

function setInputEnabled(enabled) {
    inputEl.disabled = !enabled;
    sendBtn.disabled = !enabled;
}

function clearChat() {
    conversationHistory = [];
    messagesEl.innerHTML = '';
    removeAttachment();
    inputEl.focus();
}

function handleKey(e) {
    if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
    }
}

inputEl.addEventListener('input', function() {
    this.style.height = 'auto';
    this.style.height = Math.min(this.scrollHeight, 120) + 'px';
});

function extractSources(data) {
    var sources = [];
    try {
        var gm = data.candidates[0].groundingMetadata;
        if (gm && gm.groundingChunks) {
            for (var i = 0; i < gm.groundingChunks.length; i++) {
                var chunk = gm.groundingChunks[i];
                if (chunk.web) {
                    sources.push({ uri: chunk.web.uri, title: chunk.web.title || '' });
                }
            }
        }
    } catch(e) {}
    return sources;
}

async function sendMessage() {
    var text = inputEl.value.trim();
    if (!text && !pendingAttachment) return;
    if (!apiKey) { openSettings(); return; }

    inputEl.value = '';
    inputEl.style.height = 'auto';

    var parts = [];
    var attachDataUrl = null;

    if (pendingAttachment) {
        parts.push({ inlineData: { mimeType: pendingAttachment.mimeType, data: pendingAttachment.base64 } });
        if (pendingAttachment.mimeType.startsWith('image/')) {
            attachDataUrl = pendingAttachment.dataUrl;
        }
    }
    if (text) {
        parts.push({ text: text });
    }

    var userEntry = { role: 'user', parts: parts };
    conversationHistory.push(userEntry);

    appendBubble('user', text, attachDataUrl);
    removeAttachment();

    var loadingEl = appendLoadingBubble();
    setInputEnabled(false);

    var url = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=' + apiKey;

    var body = {
        contents: conversationHistory,
        systemInstruction: {
            parts: [{ text: SYSTEM_INSTRUCTION }]
        },
        tools: [{ googleSearch: {} }],
        generationConfig: {
            temperature: 0.7,
            maxOutputTokens: 2048
        }
    };

    try {
        var response = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body)
        });

        if (!response.ok) {
            var errData = {};
            try { errData = await response.json(); } catch(e) {}
            var errMsg = response.status === 429
                ? 'Rate limit reached. Wait a moment and try again.'
                : response.status === 403
                ? 'API key invalid or access denied. Check key in settings.'
                : 'API error ' + response.status + ': ' + (errData.error && errData.error.message ? errData.error.message : response.statusText);
            replaceLoadingWithError(loadingEl, errMsg);
            conversationHistory.pop();
            return;
        }

        var data = await response.json();

        if (!data.candidates || !data.candidates[0] || !data.candidates[0].content) {
            var blockReason = data.candidates && data.candidates[0] && data.candidates[0].finishReason
                ? data.candidates[0].finishReason
                : (data.promptFeedback && data.promptFeedback.blockReason ? data.promptFeedback.blockReason : 'unknown');
            replaceLoadingWithError(loadingEl, 'Response blocked: ' + blockReason);
            conversationHistory.pop();
            return;
        }

        var reply = data.candidates[0].content.parts[0].text;
        var sources = extractSources(data);
        conversationHistory.push({ role: 'model', parts: [{ text: reply }] });
        replaceLoadingWithContent(loadingEl, reply, sources);
    } catch (err) {
        var msg = err instanceof TypeError
            ? 'Network error. Check your connection.'
            : 'Unexpected error: ' + err.message;
        replaceLoadingWithError(loadingEl, msg);
        conversationHistory.pop();
    } finally {
        setInputEnabled(true);
        inputEl.focus();
        scrollToBottom();
    }
}

(function injectManifest() {
    var manifest = { name: 'Beat', short_name: 'Beat', start_url: '.', display: 'standalone', background_color: '#1a1a2e', theme_color: '#0f3460' };
    var blob = new Blob([JSON.stringify(manifest)], { type: 'application/manifest+json' });
    var link = document.createElement('link');
    link.rel = 'manifest';
    link.href = URL.createObjectURL(blob);
    document.head.appendChild(link);
})();

(function fixMobileKeyboard() {
    if (!window.visualViewport) return;
    var container = document.querySelector('.chat-container');
    function onResize() {
        var vvh = window.visualViewport.height;
        var vvOffsetTop = window.visualViewport.offsetTop;
        container.style.height = vvh + 'px';
        container.style.transform = 'translateY(' + vvOffsetTop + 'px)';
    }
    window.visualViewport.addEventListener('resize', onResize);
    window.visualViewport.addEventListener('scroll', onResize);
    inputEl.addEventListener('focusin', function() {
        setTimeout(function() {
            inputEl.scrollIntoView({ block: 'end', behavior: 'smooth' });
        }, 300);
    });
})();
</script>
</body>
</html>
